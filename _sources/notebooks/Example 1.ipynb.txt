{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "e2df0ca2-f61d-4336-ba4c-abb4810b4372",
   "metadata": {},
   "source": [
    "# Importing data to Spatial data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "af90b58a-0dc7-4c64-8839-7e87fc706fc0",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<xarray.core.options.set_options at 0x7f35c6832bb0>"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from skimage.io import imread\n",
    "import pandas as pd\n",
    "import xarray as xr\n",
    "xr.set_options(display_style='text')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "69fb2eab-d1fe-4212-8d20-617b64a410ed",
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "sys.path.append('/home/voehring/voehring/notebooks/spatial-data')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "965c2467-1834-47fd-b4cc-9bcccec4f6c9",
   "metadata": {},
   "outputs": [],
   "source": [
    "import spatial_data"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "598c8966-9b8f-43dc-bc2b-c38a07243af0",
   "metadata": {},
   "source": [
    "## Importing raw data\n",
    "\n",
    "Spatial data implements useful accessors that complement `xarray.Dataset` objects. In order to use them we hence need to convert our image data to `xarray` objects. Here, we assume that our data comes in form of a `tiff` files. To read them into our session we use the `skimage` imread function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "68dd0f5c-16c6-461a-b116-c3d25c11235e",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_image = imread('../../tests/test_files/input.tiff')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "44f25306-ee78-4471-bb85-751036ecf167",
   "metadata": {},
   "source": [
    "By inspecting the `shape` of our image we see that it contains 5 channels and 500 pixels in `x,y` directions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "f1a12dc1-3045-4fde-931e-4b8a049928eb",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(5, 500, 500)"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "test_image.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "da072b2a-259f-4dae-8060-4ad7616b8e4a",
   "metadata": {},
   "source": [
    "To obtain an `xarray` object that is compatible with `spatial_data` we pass the image to the `spatial_data.load_image_data` function. The `channel_coords` argument enables us pass the appropriate channel names."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "306a4717-fa1d-4f53-b888-cc253b9ee741",
   "metadata": {},
   "outputs": [],
   "source": [
    "img = spatial_data.load_image_data(test_image, channel_coords=['Hoechst', 'CD4', 'CD8', 'FOXP3', 'BCL6'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "47a3213e-c7b6-4cbd-bf17-4f761eab902d",
   "metadata": {},
   "source": [
    "`spatial_data.load_image_data` returns an xarray object that we can simply inspect by calling in an jupyter cell. Note that the image is stored as the data variable `_image`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "c79fc559-9704-4c38-a521-484ab37d0b26",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<pre>&lt;xarray.Dataset&gt;\n",
       "Dimensions:   (channels: 5, y: 500, x: 500)\n",
       "Coordinates:\n",
       "  * channels  (channels) &lt;U7 &#x27;Hoechst&#x27; &#x27;CD4&#x27; &#x27;CD8&#x27; &#x27;FOXP3&#x27; &#x27;BCL6&#x27;\n",
       "  * y         (y) int64 0 1 2 3 4 5 6 7 8 ... 492 493 494 495 496 497 498 499\n",
       "  * x         (x) int64 0 1 2 3 4 5 6 7 8 ... 492 493 494 495 496 497 498 499\n",
       "Data variables:\n",
       "    _image    (channels, y, x) uint16 10816 12359 14504 10965 ... 147 129 149 59</pre>"
      ],
      "text/plain": [
       "<xarray.Dataset>\n",
       "Dimensions:   (channels: 5, y: 500, x: 500)\n",
       "Coordinates:\n",
       "  * channels  (channels) <U7 'Hoechst' 'CD4' 'CD8' 'FOXP3' 'BCL6'\n",
       "  * y         (y) int64 0 1 2 3 4 5 6 7 8 ... 492 493 494 495 496 497 498 499\n",
       "  * x         (x) int64 0 1 2 3 4 5 6 7 8 ... 492 493 494 495 496 497 498 499\n",
       "Data variables:\n",
       "    _image    (channels, y, x) uint16 10816 12359 14504 10965 ... 147 129 149 59"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "img"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a5478c79-7005-4e29-a651-c9204b1a734b",
   "metadata": {},
   "source": [
    "## Adding a segmentation mask\n",
    "\n",
    "We may have a segmentation mask for our image ready. To make use of it we can add it to our `img` object."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "fc8ce031-39d3-4318-94ed-dddacdf71fb9",
   "metadata": {},
   "outputs": [],
   "source": [
    "seg = imread('../../tests/test_files/segmentation.tiff')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "91b52e79-0644-4d47-b9bd-c3575e5e7148",
   "metadata": {},
   "source": [
    "It is important to note that the dimensions of the segmentation mask has to match the `x` and `y` dimension of our original image."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "129eb621-1a23-4216-80ba-f64fa7191500",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(500, 500)"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "seg.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d9d10d75-87ab-46e0-8a84-1489566a8865",
   "metadata": {},
   "source": [
    "Now, to add the segmentation mask we call the `se.add_segmentation` accessor. This will append the the segmentation mask to our image object and store it under the data variable `_segmentation`. Additionally, it will add an additional data variable `_obs` that is designed contain metdata for each segmentation object, i.e. cell. This table is initialised to contain the `x` and `y` coordinates of each cell."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "08540236-b128-4f01-9dc0-70a8763ba6a3",
   "metadata": {},
   "outputs": [],
   "source": [
    "img = img.se.add_segmentation(seg)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "7154f839-bd9b-4311-ba9c-2c8c0a14b255",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<pre>&lt;xarray.Dataset&gt;\n",
       "Dimensions:        (cells: 3640, features: 2, channels: 5, y: 500, x: 500)\n",
       "Coordinates:\n",
       "  * cells          (cells) int64 12 77 91 158 ... 218763 218775 218790 218917\n",
       "  * features       (features) &lt;U2 &#x27;_y&#x27; &#x27;_x&#x27;\n",
       "  * channels       (channels) &lt;U7 &#x27;Hoechst&#x27; &#x27;CD4&#x27; &#x27;CD8&#x27; &#x27;FOXP3&#x27; &#x27;BCL6&#x27;\n",
       "  * y              (y) int64 0 1 2 3 4 5 6 7 ... 492 493 494 495 496 497 498 499\n",
       "  * x              (x) int64 0 1 2 3 4 5 6 7 ... 492 493 494 495 496 497 498 499\n",
       "Data variables:\n",
       "    _obs           (cells, features) float64 139.8 49.25 47.77 ... 322.0 454.5\n",
       "    _image         (channels, y, x) uint16 10816 12359 14504 ... 129 149 59\n",
       "    _segmentation  (y, x) int32 63194 63194 63194 63194 ... 59633 59633 59633</pre>"
      ],
      "text/plain": [
       "<xarray.Dataset>\n",
       "Dimensions:        (cells: 3640, features: 2, channels: 5, y: 500, x: 500)\n",
       "Coordinates:\n",
       "  * cells          (cells) int64 12 77 91 158 ... 218763 218775 218790 218917\n",
       "  * features       (features) <U2 '_y' '_x'\n",
       "  * channels       (channels) <U7 'Hoechst' 'CD4' 'CD8' 'FOXP3' 'BCL6'\n",
       "  * y              (y) int64 0 1 2 3 4 5 6 7 ... 492 493 494 495 496 497 498 499\n",
       "  * x              (x) int64 0 1 2 3 4 5 6 7 ... 492 493 494 495 496 497 498 499\n",
       "Data variables:\n",
       "    _obs           (cells, features) float64 139.8 49.25 47.77 ... 322.0 454.5\n",
       "    _image         (channels, y, x) uint16 10816 12359 14504 ... 129 149 59\n",
       "    _segmentation  (y, x) int32 63194 63194 63194 63194 ... 59633 59633 59633"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "img"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7cdec8e8-13d6-4ed2-8457-2555b1e4a580",
   "metadata": {},
   "source": [
    "Taking a closer look at the `img` object, we find that new coordinates `cells` and `features` were added."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5f3307f6-af41-44fb-8fe1-a7429fe07935",
   "metadata": {},
   "source": [
    "## Adding cell type annotations\n",
    "\n",
    "Finally, we may want to add cell type annotations that assign unique labels to each segmented object of our image."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "98d90466-ee3b-4a2f-94d4-72cd29554df8",
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.read_csv('../../tests/test_files/labels.csv', index_col=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "3872c040-6b16-4e5c-beb7-4a36dfc086f1",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<xarray.core.options.set_options at 0x7fe601627a60>"
      ]
     },
     "execution_count": 43,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bdf01d88-dde8-4824-8d4b-a9a6da0f9e7d",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "spat-data",
   "language": "python",
   "name": "spat-data"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
